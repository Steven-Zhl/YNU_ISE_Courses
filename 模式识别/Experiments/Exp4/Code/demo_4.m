%----------------------- 本程序为第四章感知器算法的示例代码 -----------------------%
close all;
clear all;
clc;

% 训练样本来自两类：正类和负类，每类有两个样本，共有四个训练样本
X = [0, 0; 0, -1; 1, 0; 1, 1]; % 四个训练样本，每行为一个样本，每个样本为一个二维向量（即每个样本有两个属性）
classes = [1, 1, -1, -1]; % 训练样本的类别，1表示正类，2表示负类

w0 = [0, 0, 0]; % 感知器的增广权向量的初始值
c = 1; % 修正系数
[w, k] = PA(X, w0, c, classes); % 调用执行感知器算法的PA子函数，w为最终的增广权向量， k为w的迭代更新次数

syms x1 x2; % 定义符号变量x1和x2（分别表示样本的第一个和第二个属性），用于线性判别函数的表示
d = w(1) * x1 + w(2) * x2 + w(3); % 线性判别函数的表示

% 画出四个训练样本的分布图以及决策面，在画决策面时采用的方法为令线性判别函数等于0，找出x1和x2的关系（固定其中一个属性，将另一个属性用固定属性表示）
figure(1),
plot(X(:, 1), X(:, 2), 'r*'); axis([-0.5 1.5 -1.5 1.5]); hold on % 画出四个训练样本的分布图
x2 = [-1.5:0.1:1.5]; % 固定属性x2
x1 = (-w(2) * x2 - w(3)) / w(1); % 令d=0，用x2和w来表示x1
plot(x1, x2, '-b'); % 画出决策面

% 输出w的值和w的迭代更新次数
fprintf('w的值为w(1)=%4.2f, w(2)=%4.2f, w(3)=%4.2f\n', w(1), w(2), w(3));
fprintf('w的迭代更新次数为%d\n', k);

function [W, k] = PA(X, W, c, classes)
    % X为训练样本形成的矩阵，训练样本的个数为N；W为权向量；c为校正增量
    % classes为各训练样本的类别且为一个N维向量，ω1类用1表示，ω2类用-1表示
    [N, n] = size(X); % 训练样本的大小N*n，N即训练样本的个数，n即每个训练样本的维数
    A = ones(N, 1);
    X1 = [X A]; % 将训练样本写成增广向量形式
    % 对训练样本规范化
    for i = 1:N
        X1(i, :) = classes(i) * X1(i, :);
    end

    k = 0; % 迭代次数
    a = 0; % 每一轮迭代中判别函数小于或等于0的个数，即每轮中错判的次数
    b = 0; % 迭代轮数的总数
    b = b + 1;

    for j = 1:N
        if dot(W, X1(j, :), 2) > 0
            k = k + 1;
            W = W;
        else
            a = a + 1;
            W = W + c * X1(j, :);
            k = k + 1;
        end
    end
    while (a >= 1)
        a = 0;
        b = b + 1;
        for j = 1:N
            if dot(W, X1(j, :), 2) > 0
                k = k + 1;
                W = W;
            else
                a = a + 1;
                W = W + c * X1(j, :);
                k = k + 1;
            end
        end
    end
end
